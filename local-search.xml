<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>游记 | 20230318 英语一考</title>
    <link href="/2023/%E6%B8%B8%E8%AE%B0-20230318-%E8%8B%B1%E8%AF%AD%E4%B8%80%E8%80%83/"/>
    <url>/2023/%E6%B8%B8%E8%AE%B0-20230318-%E8%8B%B1%E8%AF%AD%E4%B8%80%E8%80%83/</url>
    
    <content type="html"><![CDATA[<center><h3>《十五年的过往》</h3><p>如果可以，请让我执笔几句诗行<br> 像十五年前那样<br>那是我们萌生羞涩感情的萌芽<br>  让内心彷徨<br><br>后来，我们走到了乞力马扎罗山上<br>在那里<br>我们大声呼喊<br>  在那里<br>我们互诉情肠<br>我向你承诺<br>我会让你幸福安康<br>我找了三份工作<br>只为多赚碎银几两<br>哪怕我那样繁忙<br><br>你是我不可触碰的梦想<br>研究神经元的科学家<br>却每一次都让我在脑中徜徉<br>而我只是一个普通的画家<br>忙碌一周穷穷光光<br>偶尔只能骑骑大象<br><br>我约你一起走进那家餐馆<br>你说羡慕老板那样<br>做大做强<br>也就是在那天<br>那顿饭<br>击碎了我自卑的心房<br>我悲痛欲绝<br>走在冬日大河的冰上<br>我萎靡不振前路迷茫<br>我看到河里冬泳的人们<br>我忽的燃起了希望<br>我加入他们只为把你遗忘<br><br>十五年后的今天<br>我走在伦敦的大街小巷<br>十五年后的今天<br>你牵着孩子的手走过我的身旁<br>那一刻的回眸<br>粘连的情丝让春风都要流浪<br>出于礼貌的挥手<br>喜出望外的慌张<br>“要一起吃顿饭吗？”<br>“像十五年前那样。”</p></center><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h3><p>查了考点，怎么在汇文阿（恼，班里同学好多都在一中、耀华</p><center><img src="http://static.coraa.cn/img/202303191928372.png" style="zoom:50%;" /></center><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>学校是考点校，故中午就放假了. 上午四节课一直在练单选、完型，似乎正确率还是不太稳定，但大抵是没有什么大问题的.</p><p>下午跑外面打印店印了准考证，晚上写了 $2010-2022$ 十三年的单选题，神清气爽.</p><p>班群里发了一套诈骗题，挺吓人的.</p><center><img src="http://static.coraa.cn/img/202303191931352.jpg" style="zoom:50%;" /></center><p>只有十五道单选，做了还是有错，sad.</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>早上起的挺早，本来想起来抄一抄短语的<del>（好记性不如烂笔头）</del>，后来还是没有真的去抄，只是打开五三小本看了几眼.</p><p>溜达到考点校大抵是 <code>7:50</code> 前后，门口等了没几分钟就可以进去了.</p><p><img src="http://static.coraa.cn/img/202303191937341.jpg"></p><p>成为了我校第一个签到的人.</p><p>排队的时候和同学猜作文，我赌它会考介绍某本书的作文（没赌对）.</p><p>和同学说冲 $130$ 保 $120$，考到 $135$ 就可以彻底摆烂英语了.</p><p>事实上我是很清楚自己水平的，平时模拟都没考过 $130$，所以期望有 $120$ 分就很好了.</p><p><code>8:30</code> 打铃进考场，汇文的楼梯没有窗户，感觉很压抑，好在教室里是很敞亮的.</p><p><code>8:55</code> 发了卷子，作文和 <code>活雷锋</code> 有关，一眼看上去其实很简单，感觉比较容易写.</p><p><code>9:00</code> 听铃声开始考，考场里的电波表确实很准，一秒都不差.</p><p><code>9:10</code> 写完了单选，其实写得有些慢了，题很简单，目测没啥不确定的题.</p><p>后来单选争议最大的题居然是最后一道，还好我选对了（汗</p><blockquote><p>discussion (where) the teacher asked ……</p></blockquote><p>有同学说考的同位语，要选 <code>that</code>. 但天津卷似乎确实是不考同位语了.（汗，很异或阿.</p><p>完型讲了作者跟着非洲小哥爬乞力马扎罗山的故事，感觉有些东西有点抽象.</p><p>第一遍写完型的时候因为不认识 <code>peak（峰）</code> 又没细心读题错了一道，后面还有个空说装备怎么样在小哥脑袋上，要选 <code>balanced</code>，但我选成了 <code>folded</code>.（其实这题如果配了下面这张图片，就很明显了）</p><p><img src="http://static.coraa.cn/img/202303191953613.jpg"></p><p>后面还有个 <code>cheerful</code> 选成了 <code>ambitious</code>（我当时觉得挺有道理的）现在看来脑子确实不太正常.</p><p>阅读 <code>A</code> 篇确实是简单的，几分钟写完.</p><p><code>B</code> 篇就开始令人异或了. 其中第五道题似乎是整套卷子里争议最大的一道题.</p><p>有同学发起了一个投票，结果如下：</p><center><img src="http://static.coraa.cn/img/202303191957038.jpg" style="zoom:30%;" /></center><p>最后似乎大家都认为 <code>tackle...</code> 是正确答案，无语凝噎.</p><p><code>C</code> 篇介绍了神经科学与艺术作品相关的研究领域，但我把它当成作者看完科学论文产生的一些感想了. 于是最后一题就选错了.</p><p>中间还错了一道奇怪的题，后来在群友的提示下搞明白了.</p><p>是我想太多了，我想出来了一些于文无据的东西.</p><p><code>D</code> 篇是选自《新科学家》(New Scientist) 的<code>To err is fruitful</code>，具体内容可以参考 <a href="https://mp.weixin.qq.com/s/Ov6lCFd-Cofray_-1MobSA">故意犯错可能是最靠谱的学习方法 | 外刊精读</a> 这篇文章.</p><p><del>是这样的，故意犯错确实是最靠谱的学习方法，我这一篇错了三道题，是不是下次就能学好了.</del></p><p>第一题我到现在不太理解为什么是 <code>普遍的观点</code> 而不是 <code>人们的错误认知</code>. </p><p>最后一题选恰当标题，因为不确定 <code>fruitful</code> 是什么意思，就选了 <code>Error prevents failure</code>.</p><p>感觉大抵是细节没搞明白，只是抓了大体的主旨（故意犯错有利于学习、成功，etc.）</p><p>写完阅读回去“检查”了一遍完型，改了两道题，全都改错了. sad.</p><p>浪费了好多时间，二卷只剩下 $30\min$，阅表感觉还不是那么简单，占了十几分钟.</p><p>剩下十几分钟给作文，属实是心慌，没打草稿，逻辑好像还写得有点问题.</p><p>写完最后一个字母刚好打铃停止答题.</p><p>手抖.</p><p>收完笔试答题卡就开始考听力，语速果真是很慢的，场内自我感觉良好.</p><p>听力 <code>B</code> 卷第一个语段很有意思，</p><p><img src="http://static.coraa.cn/img/202303192015593.jpg"></p><p>女主：<code>You ?!! Married ?!?! To ?????</code></p><p>听得太过专注以至于忘了做题. </p><p>没注意听她在伦敦咋样，只听见工作不是想象中的好，伦敦 <code>too expensive</code>，etc.</p><p>漏了房租太贵的细节，选错了一道题（悲）我以为说的伦敦物价贵呢.</p><p>结束后润出考场，心情确实很复杂，想着听力能满分就足够了，反正笔试那个作文已经不太好了.</p><p><img src="http://static.coraa.cn/img/202303192039770.jpg"></p><p>汇文？清华！</p><p>考点门口被家长堵死了. 感觉让家长都来门口堵是个很不好的事情，费了好大劲才挤出人群.</p><p><img src="http://static.coraa.cn/img/202303192029662.jpg"></p><p>出来和大家吹水聊天，发现我改的好几道题都改错了，sad.</p><p>听力我实在记不清我 <code>A</code> 卷到底有没有满分，如果 <code>A</code> 和 <code>B</code> 都有错的话岂不是大悲.</p><p>不知道是不是场内数错了，我真的怀疑我 <code>A</code> 卷错了某道题，但又不知道是哪一道.</p><p>一整个下午看大家交流的有争议的题我都没错.</p><p>晚上心情很悲伤，虽然自己不是很在意这次的成绩，但依旧能清楚地感觉到人与人之间的差距比人与狗都大.</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>同学们都在讨论能不能一卷扣 $10$ 分以内、$5$ 分以内，我却看着我改错的两道完型两道阅读陷入沉思.</p><p>我练了好久的单选，在这么简单的单选题面前，意义何在?</p><p>单选确实是没错，反倒是错了四道完型五道阅读，实在是痛.</p><p>显然要继续学下去了，这 $110$ 多分怎么够我用的嘛.</p><p>笑死，一天的时间目标从 $135$ <code>swing</code> 到了 $120$，什么消愁.</p><p>感觉大家都在为 $130$ 多分上不了 $135$ 抑或是上不了 $140$ 而发愁，和他们比起来我倒是可以笃定学下去的念头了.</p><p>考试院说预计 <strong>四月中旬</strong> 出成绩，不好评价.</p><h3 id="更多梗图"><a href="#更多梗图" class="headerlink" title="更多梗图"></a>更多梗图</h3><p><img src="http://static.coraa.cn/img/202303192036142.jpg"></p><p><img src="http://static.coraa.cn/img/202303192037562.jpg"></p><p><img src="http://static.coraa.cn/img/202303192037300.jpg"></p><p><img src="http://static.coraa.cn/img/202303192037437.jpg"></p><p><img src="http://static.coraa.cn/img/202303192037245.jpg"></p><p>天津考生才华横溢.</p>]]></content>
    
    
    
    <tags>
      
      <tag>高考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 849 (Div. 4)</title>
    <link href="/2023/Codeforces-Round-849-Div-4/"/>
    <url>/2023/Codeforces-Round-849-Div-4/</url>
    
    <content type="html"><![CDATA[<p><del>前八道甚至七道都是简单题.</del></p><h3 id="A-Codeforces-Checking"><a href="#A-Codeforces-Checking" class="headerlink" title="A. Codeforces Checking"></a><a href="https://codeforces.com/contest/1791/problem/A">A. Codeforces Checking</a></h3><blockquote><p>输入一个字符，判断这个字符在 <code>codeforces</code> 中有没有出现过.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string cf = <span class="hljs-string">&quot;codeforces&quot;</span>;<br><span class="hljs-type">char</span> inp;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    std::cin &gt;&gt; inp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : cf) <span class="hljs-keyword">if</span>(i == inp)&#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="B-Following-Directions"><a href="#B-Following-Directions" class="headerlink" title="B. Following Directions"></a><a href="https://codeforces.com/contest/1791/problem/B">B. Following Directions</a></h3><blockquote><p>给一串字符串，每个字符代表一次操作，有上下左右（UDLR）四种操作，表示向上、向下、向左、向右的移动.</p><p>从初始坐标 $(0, 0)$ 开始移动，问路径是否经过 $(1, 1)$</p></blockquote><p>模拟.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> len;<br>std::string inp;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    std::cin &gt;&gt; len &gt;&gt; inp;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m : inp)&#123;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-string">&#x27;U&#x27;</span>) y++;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-string">&#x27;D&#x27;</span>) y--;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-string">&#x27;L&#x27;</span>) x--;<br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-string">&#x27;R&#x27;</span>) x++;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span> &amp;&amp; y == <span class="hljs-number">1</span>)&#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;YES&quot;</span>); <span class="hljs-keyword">return</span>; &#125;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;NO&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C-Prepend-and-Append"><a href="#C-Prepend-and-Append" class="headerlink" title="C. Prepend and Append"></a><a href="https://codeforces.com/contest/1791/problem/C">C. Prepend and Append</a></h3><blockquote><p>给一个 01 串，每次操作可以从两边各删一个字符（前提是两边字符不同），问最多可以操作多少次.</p></blockquote><p>模拟.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> len;<br>std::string inp;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    std::cin &gt;&gt; len &gt;&gt; inp;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; inp[l] - <span class="hljs-string">&#x27;0&#x27;</span> + inp[r] - <span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-number">1</span>)&#123;<br>        l++, r--;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, r - l + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="D-Distinct-Split"><a href="#D-Distinct-Split" class="headerlink" title="D. Distinct Split"></a><a href="https://codeforces.com/contest/1791/problem/D">D. Distinct Split</a></h3><blockquote><p>给一个字符串，你要把这个字符串从中间割开分成 $a, b$ 两个部分，记 $f(str)$ 为字符串 $str$ 中不同字符的个数，求 $f(a)+f(b)$ 的最大值.</p></blockquote><p>枚举切割位置，更新答案. 要注意的是：必须从中间切（$a, b$ 都不是空的）.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> len;<br>std::string inp;<br>std::map &lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; lm, rm;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    lm.<span class="hljs-built_in">clear</span>(); rm.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>    std::cin &gt;&gt; len &gt;&gt; inp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : inp) l += lm[c]++ == <span class="hljs-number">0</span>;<br> <br>    l -= --lm[inp[len - <span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>;<br>    r += rm[inp[len - <span class="hljs-number">1</span>]]++ == <span class="hljs-number">0</span>;<br>    ans = l + r;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len - <span class="hljs-number">2</span>; i; i--)&#123;<br>        l -= --lm[inp[i]] == <span class="hljs-number">0</span>;<br>        r += rm[inp[i]]++ == <span class="hljs-number">0</span>;<br>        ans = std::<span class="hljs-built_in">max</span>(ans, l + r);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="E-Negatives-and-Positives"><a href="#E-Negatives-and-Positives" class="headerlink" title="E. Negatives and Positives"></a><a href="https://codeforces.com/contest/1791/problem/E">E. Negatives and Positives</a></h3><blockquote><p>给一序列 $a_1, a_2, \dots, a_n$，每次操作可以选相邻两个元素，把他们的正负翻转. 可以操作任意次，求最终 $\sum a_i$ 的最大值.</p></blockquote><p>如果相邻两个元素都是负的，翻转后它们都会变成正的.</p><p>如果相邻两个元素一正一负，翻转后负号会从其中一个元素移动到另一个元素上.</p><p>易得结论：</p><ul><li>当有偶数个负数时，我们可以通过若干次操作，全部翻转成正数.</li><li>当有奇数个负数时，无论经过多少次操作，必然会剩下一个负数.</li></ul><p>要使得 $\sum a_i$ 最大，剩下的一个负号要加在绝对值最小的元素上.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    ll n = <span class="hljs-built_in">read</span>(), cnt = <span class="hljs-number">0</span>, mi = <span class="hljs-number">0x7f7f7f7f</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        ll now = <span class="hljs-built_in">read</span>();<br>        cnt += now &lt; <span class="hljs-number">0</span>;<br>        now = now &lt; <span class="hljs-number">0</span> ? -now : now;<br>        mi = std::<span class="hljs-built_in">min</span>(mi, now);<br>        ans += now;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, cnt &amp; <span class="hljs-number">1</span> ? ans - mi - mi : ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>要注意的是：$a_i \in [-10^9, 10^9]$，不开 <code>long long</code> 的话，会爆炸.</p><h3 id="F-Range-Update-Point-Query"><a href="#F-Range-Update-Point-Query" class="headerlink" title="F. Range Update Point Query"></a><a href="https://codeforces.com/contest/1791/problem/F">F. Range Update Point Query</a></h3><blockquote><p>给一序列 $a_1, a_2, \dots, a_n$，对它进行若干次操作，操作类型如下：</p><ul><li><code>1 l r</code>：对任意 $a_i \ (i \in [l, r])$，把 $a_i$ 更新成 $a_i$ 各位数之和.</li><li><code>2 p</code>：查询 $a_p$ 的值.</li></ul></blockquote><p>涉及到区间修改、单点查询，考虑使用树状数组维护修改次数，查询时再进行相应的修改.</p><p>注意到：当 $x &lt; 10$ 时，$x$ 各位数之和仍是 $x$ 本身. 我们需要利用此性质避免过多无用计算导致的 <code>TLE</code>. </p><center><img src="https://static.coraa.cn/img/202302041110818.png" alt="警钟长鸣" style="zoom:50%;"/><br><small>警钟长鸣</small></center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, m, tree[<span class="hljs-number">200010</span>], a[<span class="hljs-number">200010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <span class="hljs-keyword">return</span> x &amp; -x; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">0</span>)&#123;<br>        ret += tree[p];<br>        p -= <span class="hljs-built_in">lowbit</span>(p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(p &lt;= n)&#123;<br>        tree[p] += x;<br>        p += <span class="hljs-built_in">lowbit</span>(p);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        ret += x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) tree[i] = <span class="hljs-number">0</span>, a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">read</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">// opt == 1</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-built_in">read</span>(), r = <span class="hljs-built_in">read</span>();<br>            <span class="hljs-built_in">add</span>(l, <span class="hljs-number">1</span>); <span class="hljs-built_in">add</span>(r+<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// opt == 2</span><br>            <span class="hljs-type">int</span> p = <span class="hljs-built_in">read</span>(); <span class="hljs-keyword">if</span>(a[p] &lt; <span class="hljs-number">10</span>)&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[p]); <span class="hljs-keyword">continue</span>; &#125;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-built_in">qry</span>(p); <span class="hljs-built_in">add</span>(p, -cnt); <span class="hljs-built_in">add</span>(p+<span class="hljs-number">1</span>, cnt);<br>            <span class="hljs-keyword">while</span>(a[p] &gt;= <span class="hljs-number">10</span> &amp;&amp; cnt--) a[p] = <span class="hljs-built_in">calc</span>(a[p]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a[p]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="G1-Teleporters-Easy-Version"><a href="#G1-Teleporters-Easy-Version" class="headerlink" title="G1. Teleporters (Easy Version)"></a><a href="https://codeforces.com/contest/1791/problem/G1">G1. Teleporters (Easy Version)</a></h3><blockquote><p>在非负数轴上的整数点中，除原点以外均有一传送台（可以把你传回原点），传送过程消耗 $a_i$ 个金币.</p><p>最开始，你在原点处. 你可以花费 $1$ 个金币向左或向右移动一个单位，也可以花费 $a_i$ 个金币通过未失效的传送台传送回原点.</p><p>传送台只能使用一次，用完就失效了.</p><p>你现在有 $c$ 个金币，问你最多能用几个传送台.</p></blockquote><p>想要使用一个传送台，我们需要从原点走到传送台，再花费对应的代价回到原点.</p><p>所以第 $i$ 个传送台的“使用代价”为 $a_i + i$，我们只需要按照其使用代价从小到大排序，看看手里的硬币够用几个的就行了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll n, c, a[<span class="hljs-number">200005</span>];<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    n = <span class="hljs-built_in">read</span>(), c = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) a[i] = <span class="hljs-built_in">read</span>() + i;<br>    std::<span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(now + a[i] &lt;= c) now += a[i];<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure><p><del>这是个比较愚蠢的写法，但我懒得改了.</del></p><h3 id="G2-Teleporters-Hard-Version"><a href="#G2-Teleporters-Hard-Version" class="headerlink" title="G2. Teleporters (Hard Version)"></a><a href="https://codeforces.com/contest/1791/problem/G2">G2. Teleporters (Hard Version)</a></h3><p><del>睡觉去了.</del></p><hr><p>总结：手速太慢，还没阿克（悲</p><p>债见~</p>]]></content>
    
    
    
    <tags>
      
      <tag>CF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 848 (Div. 2)</title>
    <link href="/2023/Codeforces-Round-848-Div-2/"/>
    <url>/2023/Codeforces-Round-848-Div-2/</url>
    
    <content type="html"><![CDATA[<p>Hexo 标题里不能带 <code>#</code> 阿（汗</p><p>写完地理选择就去打了，做完 A，B 回来继续写地理综合.</p><h3 id="A-Flip-Flop-Sum"><a href="#A-Flip-Flop-Sum" class="headerlink" title="A. Flip Flop Sum"></a><a href="https://codeforces.com/contest/1778/problem/A">A. Flip Flop Sum</a></h3><blockquote><p>给一个只包含 $1$ 和 $-1$ 的序列，你必须选两个相邻的元素翻转（<code>1</code>变<code>-1</code>、<code>-1</code>变<code>1</code>），问翻转后 $\sum a_i$ 最大值.</p></blockquote><p>记 $\Delta$ 为翻转操作的“收益”，则 $Ans &#x3D; \sum a_i + \Delta$，我们只需要使 $\Delta$ 最大，就能得到最大答案.</p><p>相邻的两个数可以分为以下情况：</p><ul><li>都是 $1$：$\Delta &#x3D; -4$；</li><li>都是 $-1$：$\Delta &#x3D; 4$；</li><li>一个 $1$ 一个 $-1$：$\Delta &#x3D; 0$.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> mxd = <span class="hljs-number">-4</span>, ans, lst;<br>    ans = lst = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-type">int</span> now = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span>(now == <span class="hljs-number">-1</span> &amp;&amp; lst == <span class="hljs-number">-1</span>) mxd = <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span>(now * lst == <span class="hljs-number">-1</span>) mxd = std::<span class="hljs-built_in">max</span>(mxd, <span class="hljs-number">0</span>);<br>        ans += (lst = now);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans + mxd);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="B-The-Forbidden-Permutation"><a href="#B-The-Forbidden-Permutation" class="headerlink" title="B. The Forbidden Permutation"></a><a href="https://codeforces.com/contest/1778/problem/B">B. The Forbidden Permutation</a></h3><blockquote><p>给长度为 $n$ 的序列 $p$ 和长度为 $m$ 的序列 $a$. 其中 $m \le n$，两序列中均无重复元素，保证 $a$ 序列中的数在 $p$ 里出现过.</p><p>定义 $pos(x)$ 为 $x$ 在 $p$ 序列中的下标.</p><p>对“好序列”的定义为：<strong>存在</strong> $i \in [1, m)$，满足 $pos(a_i) &gt; pos(a_{i+1})$ 或 $pos(a_i) + d &lt; pos(a_{i+1})$.</p><p>每次操作，可以交换 $p$ 中相邻两个元素，问至少需要多少次操作，可以使 $a$ 成为“好序列”.</p></blockquote><p>此题中，我们需要快速找到 $p$ 序列中某个元素的下标，所以读入时反着存.</p><p>考虑序列 $a$ 中相邻两个元素，记作 $l$ 和 $r$. 若要使 $a$ 成为“好序列”，我们需要满足：<br>$$<br>pos(l) &gt; pos(r) \ \ \ or \ \ \ pos(l) + d &lt; pos(r)<br>$$<br>若 $l$ 和 $r$ 不需要任何操作就满足了这个条件，直接输出 $0$.（只要存在一对满足，$a$ 就是“好序列”）</p><p>若未满足：</p><ul><li>考虑第一个条件：要交换 $pos(r) - pos(l)$ 次；</li><li>考虑第二个条件：要交换 $d - (pos(r) - pos(l)) + 1$ 次. 且前提为 $d \le n - 2$.</li></ul><p>遍历更新答案即可.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::map &lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0x7f7f7f7f</span>;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(), m = <span class="hljs-built_in">read</span>(), d = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        mp[<span class="hljs-built_in">read</span>()] = i;<br>    &#125;<br>    <span class="hljs-type">int</span> lst = <span class="hljs-built_in">read</span>(), now;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        now = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span>(flag || mp[now] &lt; mp[lst] || mp[now] - mp[lst] &gt; d)&#123; flag = <span class="hljs-literal">true</span>; <span class="hljs-keyword">continue</span>; &#125;<br>        ans = std::<span class="hljs-built_in">min</span>(ans, mp[now] - mp[lst]);<br>        <span class="hljs-keyword">if</span>(d &lt;= n<span class="hljs-number">-2</span>) ans = std::<span class="hljs-built_in">min</span>(ans, d - mp[now] + mp[lst] + <span class="hljs-number">1</span>);<br>        lst = now;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, flag ? <span class="hljs-number">0</span> : ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>这题坑点在于：只要 <strong>存在任意一对</strong> 相邻的元素满足上述条件，它就是“好序列”.</p><p><del>两道题都忘了写 lst &#x3D; now，A 题交之前看出来了，B 题 WA 了两发看出来了. 警钟敲烂!!!</del></p><p>债见~</p>]]></content>
    
    
    
    <tags>
      
      <tag>CF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeDB Forces 2023</title>
    <link href="/2023/TypeDB-Forces-2023/"/>
    <url>/2023/TypeDB-Forces-2023/</url>
    
    <content type="html"><![CDATA[<center><del>一车数学结论题，啥也不会. 真不如写我的物理作业了.</del></center><h3 id="A-Exponential-Equation"><a href="#A-Exponential-Equation" class="headerlink" title="A. Exponential Equation"></a><a href="https://codeforces.com/contest/1787/problem/A">A. Exponential Equation</a></h3><blockquote><p>给一个整数 $n$，找任意一对 $(x, y)$ 满足 $x^y \cdot y + y^x \cdot x &#x3D; n$. 若没有，输出 $-1$.</p></blockquote><p>容易看出，若 $n$ 为奇数，则没有符合条件的 $(x, y)$.</p><p>不妨令 $y &#x3D; 1$，则 $x$ 需满足 $2x &#x3D; n$ 即 $x &#x3D; \frac{n}{2}$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(n &amp; <span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 1\n&quot;</span>, n/<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="B-Number-Factorization"><a href="#B-Number-Factorization" class="headerlink" title="B. Number Factorization"></a><a href="https://codeforces.com/contest/1787/problem/B">B. Number Factorization</a></h3><blockquote><p>给一个整数 $n$，把它分解成 $\prod a_i^{p_i}$（$a_i &gt; 1, p_i &gt; 0$）的形式，要求 $a_i$ 是若干个<strong>不同质数</strong>之积.</p><p>求 $\sum a_i\cdot p_i$ 的最大值.</p></blockquote><p>由题，我们要先把 $n$ 分解成若干个质因数相乘的形式，过程不再赘述.</p><p>由于多次询问，需要预处理出 $\sqrt n$ 以内的质数.</p><p>为了最大化 $\sum a_i \cdot p_i$，考虑将不同质数乘在一起，其变化如下：<br>$$<br>a^i \times b^j \to (ab)^k \times a^{i-k} \times b^{j-k}<br>$$<br>由此，$\sum a_i \cdot p_i$ 的值增加了：<br>$$<br>\Delta &#x3D; kab + (i-k)a + (j-k)b - ia - jb &#x3D; k(ab - (a+b))<br>$$<br>由于 $a, b &gt; 2 \Rightarrow \Delta &gt; 0$，合并后的答案一定是更优的.</p><p>所以我们把能合并的都合并，即可最大化 $\sum a_i \cdot p_i$.</p><p>因为题目要求质数不同，所以我们计算答案时要一层一层处理：相同的质数不能合并到一起.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> prod[<span class="hljs-number">105</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    std::<span class="hljs-built_in">memset</span>(prod, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> prod);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> n = <span class="hljs-built_in">read</span>(), ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : pri)&#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n % p == <span class="hljs-number">0</span>)&#123;<br>            t++;<br>            prod[t] = prod[t] ? prod[t] * p : p;<br>            n /= p;<br>        &#125;<br>    &#125;<br>    prod[<span class="hljs-number">1</span>] = prod[<span class="hljs-number">1</span>] ? prod[<span class="hljs-number">1</span>] * n : n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) ans += prod[i];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>Q: 为什么只需要预处理出 $\sqrt n$ 以内的质数？为什么试除完剩下的 $n$ 一定是质数？</p><ul><li>若 $x$ 是 $n$ 的因数，则必然存在对应的 $y$ 满足 $xy &#x3D; n$，且 $x \le \sqrt n \le y$.</li><li>若 $\sqrt n$ 以内的质数都不是 $n$ 的因数，则 $n$ 无其他因数，所以 $n$ 为质数.</li></ul><p>太久没写忘掉了，被质因数分解卡了两小时，掉大分咯！</p><p>债见~</p>]]></content>
    
    
    
    <tags>
      
      <tag>CF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Alist-API 非官方文档</title>
    <link href="/2023/Alist-API/"/>
    <url>/2023/Alist-API/</url>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>本文档适用于 <code>Alist V3</code>.</li><li>官方文档请参考 <a href="https://alist.nn.ci/zh/">https://alist.nn.ci/zh/</a>.</li><li>接口响应格式通常为 <code>&#123;&quot;code&quot;:...,&quot;message&quot;:&quot;...&quot;,&quot;data&quot;:...&#125;</code>.</li><li>为节省空间，下文中“响应内容”为请求成功（<code>code == 200</code>）时的 <code>data</code> 部分.</li><li>若 <code>code != 200</code>，可以输出 <code>message</code> 便于进一步调试.</li><li>本文档提供某种接口封装形式作为参考，使用 <code>Python</code> 语言.</li><li>若有更新的 <code>Alist</code> 版本，本文档视情况同步更新.</li><li>时间有限，本文档暂不完善，但覆盖了大部分常用接口.</li></ul><h3 id="获取当前用户信息"><a href="#获取当前用户信息" class="headerlink" title="获取当前用户信息"></a>获取当前用户信息</h3><ul><li><p>请求地址：<code>/api/me</code></p></li><li><p>请求方式：<code>GET</code></p></li><li><p>请求头：</p><ul><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>响应内容：</p><ul><li><code>id</code>：用户id</li><li><code>username</code>：用户名</li><li><code>password</code>：未知（很多时候，它都是空的）</li><li><code>base_path</code>：用户的基本路径</li><li><code>role</code>：未知</li><li><code>permission</code>：未知</li><li><code>github_id</code>：用户 <code>github_id</code>（开启 <code>github登入</code> 后会有用，但这是个新功能）</li><li><code>otp</code>：未知</li></ul></li><li><p>说明：当请求头为空时，返回 <code>guest</code> 用户的相关信息.</p></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getProfile</span>():<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.get(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/me&#x27;</span>, headers=headers).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="通过用户名、密码获取-token（登入）"><a href="#通过用户名、密码获取-token（登入）" class="headerlink" title="通过用户名、密码获取 token（登入）"></a>通过用户名、密码获取 token（登入）</h3><ul><li><p>请求地址：<code>/api/auth/login</code></p></li><li><p>请求方式：<code>POST</code></p></li><li><p>请求头：</p><ul><li><code>Content-Type</code>: <code>application/json</code></li></ul></li><li><p>请求参数：</p><ul><li><code>username</code>：用户名</li><li><code>password</code>：密码</li></ul></li><li><p>响应内容：</p><ul><li><code>token</code>：用户 token（一定时间内有效）</li></ul></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getToken</span>(<span class="hljs-params">username, password</span>):<br>    data = &#123;<br>        <span class="hljs-string">&#x27;username&#x27;</span>: username,<br>        <span class="hljs-string">&#x27;password&#x27;</span>: password<br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.post(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/auth/login&#x27;</span>, data=json.dumps(data), headers=&#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>&#125;).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="获取一个目录下的对象列表"><a href="#获取一个目录下的对象列表" class="headerlink" title="获取一个目录下的对象列表"></a>获取一个目录下的对象列表</h3><ul><li><p>请求地址：<code>/api/fs/list</code></p></li><li><p>请求方式：<code>POST</code></p></li><li><p>请求头：</p><ul><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>请求参数：</p><ul><li><p><code>path</code>：相对当前用户 <code>base_path</code> 来说的相对路径</p></li><li><p>（可空）<code>page</code>：页码</p></li><li><p>（可空）<code>per_page</code>：每页对象个数</p></li><li><p>（可空）<code>refresh</code>：是否强制刷新（<code>bool</code>型)</p></li><li><p>（可空）<code>password</code>：路径密码</p></li></ul></li><li><p>响应内容：</p><ul><li><code>content</code>：对于每个对象来说，包含以下参数<ul><li><code>name</code>：对象名</li><li><code>size</code>：对象大小</li><li><code>is_dir</code>：是否为目录（<code>bool</code>型)</li><li><code>modified</code>：修改时间</li><li><code>sign</code>：访问令牌</li><li><code>thumb</code>：（文档）缩略图，部分驱动器可用</li><li><code>type</code>：对象类型</li></ul></li><li><code>total</code>：对象个数</li><li><code>readme</code>：目录的 <code>readme</code>（如果有的话）</li><li><code>write</code>：是否可写（<code>bool</code>型)</li><li><code>provider</code>：存储类型</li></ul></li><li><p>说明：</p><ul><li>请确保传入的 <code>path</code> 是一个目录而不是文件，否则会报错.</li><li>当请求头为空时，以 <code>guest</code> 的身份访问.</li></ul></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getObjectList</span>(<span class="hljs-params">path, password = <span class="hljs-string">&#x27;&#x27;</span></span>):<br>    data = &#123;<br>        <span class="hljs-string">&#x27;page&#x27;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&#x27;password&#x27;</span>: password,<br>        <span class="hljs-string">&#x27;path&#x27;</span>: path,<br>        <span class="hljs-string">&#x27;per_page&#x27;</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-string">&#x27;refresh&#x27;</span>: <span class="hljs-literal">False</span><br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.post(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/fs/list&#x27;</span>, data=data, headers=headers).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="获取一个对象的信息"><a href="#获取一个对象的信息" class="headerlink" title="获取一个对象的信息"></a>获取一个对象的信息</h3><ul><li><p>请求地址：<code>/api/fs/get</code></p></li><li><p>请求方式：<code>POST</code></p></li><li><p>请求头：</p><ul><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>请求参数：</p><ul><li><code>path</code>：相对当前用户 <code>base_path</code> 来说的相对路径</li><li>（可空）<code>password</code>：路径密码</li></ul></li><li><p>响应内容：</p><ul><li><code>name</code>：对象名</li><li><code>size</code>：对象大小</li><li><code>is_dir</code>：是否为目录（<code>bool</code>型)</li><li><code>modified</code>：修改时间</li><li><code>sign</code>：访问令牌</li><li><code>thumb</code>：（文档）缩略图，部分驱动器可用</li><li><code>type</code>：对象类型</li><li><code>raw_url</code>：对象直链</li><li><code>readme</code>：对象的 <code>readme</code>（如果有的话）</li><li><code>provider</code>：存储类型</li><li><code>related</code>：未知</li></ul></li><li><p>说明：当请求头为空时，以 <code>guest</code> 的身份访问.</p></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">getObjectInfo</span>(<span class="hljs-params">path, password = <span class="hljs-string">&#x27;&#x27;</span></span>):<br>    data = &#123;<br>        <span class="hljs-string">&#x27;password&#x27;</span>: password,<br>        <span class="hljs-string">&#x27;path&#x27;</span>: path<br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.post(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/fs/get&#x27;</span>, data=data, headers=headers).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><ul><li><p>请求地址：<code>/api/fs/mkdir</code></p></li><li><p>请求方式：<code>POST</code></p></li><li><p>请求头：</p><ul><li><code>Content-Type</code>: <code>application/json</code></li><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>请求参数：</p><ul><li><code>path</code>：要创建的文件夹的相对路径（例如：<code>/Local/new_folder</code>）</li></ul></li><li><p>响应内容：无特殊响应内容.</p></li><li><p>说明：</p><ul><li>当 <code>Authorization</code> 为空时，以 <code>guest</code> 的身份创建.</li><li>请确保 token 所属用户有相应权限.</li></ul></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">MakeDir</span>(<span class="hljs-params">path</span>):<br>    data = &#123; <span class="hljs-string">&#x27;path&#x27;</span>: path &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.post(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/fs/mkdir&#x27;</span>, data=json.dumps(data), headers=<span class="hljs-built_in">dict</span>(headers, **ct_json)).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><ul><li><p>请求地址：<code>/api/fs/put</code></p></li><li><p>请求方式：<code>PUT</code></p></li><li><p>请求头：</p><ul><li><code>file-path</code>：文件保存到 <code>Alist</code> 上的相对路径</li><li><code>content-length</code>：文件字节数</li><li>（可空）<code>password</code>：路径密码</li><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>请求内容：</p><ul><li>所传文件内容，如：<code>open(localPath, &#39;rb&#39;).read()</code></li></ul></li><li><p>响应内容：无特殊响应内容.</p></li><li><p>说明：</p><ul><li>当 <code>Authorization</code> 为空时，以 <code>guest</code> 的身份上传.</li><li>请确保 token 所属用户有相应权限.</li></ul></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Upload</span>(<span class="hljs-params">localPath, remotePath, fileName, password = <span class="hljs-string">&#x27;&#x27;</span></span>):<br>    upload_header = &#123;<br>        <span class="hljs-string">&#x27;UserAgent&#x27;</span>: UserAgent,<br>        <span class="hljs-string">&#x27;Authorization&#x27;</span>: Authorization,<br>        <span class="hljs-string">&#x27;File-Path&#x27;</span>: parse.quote(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;remotePath&#125;</span>/<span class="hljs-subst">&#123;fileName&#125;</span>&#x27;</span>),<br>        <span class="hljs-string">&#x27;Password&#x27;</span>: password,<br>        <span class="hljs-string">&#x27;Content-Length&#x27;</span>: <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;os.path.getsize(localPath)&#125;</span>&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.put(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/fs/put&#x27;</span>, headers=upload_header, data=<span class="hljs-built_in">open</span>(localPath, <span class="hljs-string">&#x27;rb&#x27;</span>).read()).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><ul><li><p>请求地址：<code>/api/fs/remove</code></p></li><li><p>请求方式：<code>POST</code></p></li><li><p>请求头：</p><ul><li><code>Content-Type</code>: <code>application/json</code></li><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>请求参数：</p><ul><li><code>dir</code>：对象所属目录</li><li><code>names</code>：对象名数组，即使只有一个对象，也要放到数组里</li></ul></li><li><p>响应内容：无特殊响应内容.</p></li><li><p>说明：</p><ul><li>当 <code>Authorization</code> 为空时，以 <code>guest</code> 的身份上传.</li><li>请确保 token 所属用户有相应权限.</li></ul></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Remove</span>(<span class="hljs-params"><span class="hljs-built_in">dir</span>, names</span>):<br>    data = &#123;<br>        <span class="hljs-string">&#x27;dir&#x27;</span>: <span class="hljs-built_in">dir</span>,<br>        <span class="hljs-string">&#x27;names&#x27;</span>: names<br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.post(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/fs/remove&#x27;</span>, data=json.dumps(data), headers=<span class="hljs-built_in">dict</span>(headers, **ct_json)).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><ul><li><p>请求地址：<code>/api/fs/copy</code></p></li><li><p>请求方式：<code>POST</code></p></li><li><p>请求头：</p><ul><li><code>Content-Type</code>: <code>application/json</code></li><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>请求参数：</p><ul><li><code>src_dir</code>：当前对象所属目录</li><li><code>dst_dir</code>：目标目录</li><li><code>names</code>：对象名数组，即使只有一个对象，也要放到数组里</li></ul></li><li><p>响应内容：无特殊响应内容.</p></li><li><p>说明：</p><ul><li>当 <code>Authorization</code> 为空时，以 <code>guest</code> 的身份上传.</li><li>请确保 token 所属用户有相应权限.</li></ul></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Copy</span>(<span class="hljs-params">srcDir, dstDir, names</span>):<br>    data = &#123;<br>        <span class="hljs-string">&#x27;src_dir&#x27;</span>: srcDir,<br>        <span class="hljs-string">&#x27;dst_dir&#x27;</span>: dstDir,<br>        <span class="hljs-string">&#x27;names&#x27;</span>: names<br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.post(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/fs/copy&#x27;</span>, data=json.dumps(data), headers=<span class="hljs-built_in">dict</span>(headers, **ct_json)).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="移动对象"><a href="#移动对象" class="headerlink" title="移动对象"></a>移动对象</h3><ul><li><p>请求地址：<code>/api/fs/move</code></p></li><li><p>请求方式：<code>POST</code></p></li><li><p>请求头：</p><ul><li><code>Content-Type</code>: <code>application/json</code></li><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>请求参数：</p><ul><li><code>src_dir</code>：当前对象所属目录</li><li><code>dst_dir</code>：目标目录</li><li><code>names</code>：对象名数组，即使只有一个对象，也要放到数组里</li></ul></li><li><p>响应内容：无特殊响应内容.</p></li><li><p>说明：</p><ul><li>当 <code>Authorization</code> 为空时，以 <code>guest</code> 的身份上传.</li><li>请确保 token 所属用户有相应权限.</li></ul></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Move</span>(<span class="hljs-params">srcDir, dstDir, names</span>):<br>    data = &#123;<br>        <span class="hljs-string">&#x27;src_dir&#x27;</span>: srcDir,<br>        <span class="hljs-string">&#x27;dst_dir&#x27;</span>: dstDir,<br>        <span class="hljs-string">&#x27;names&#x27;</span>: names<br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.post(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/fs/move&#x27;</span>, data=json.dumps(data), headers=<span class="hljs-built_in">dict</span>(headers, **ct_json)).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="对象重命名"><a href="#对象重命名" class="headerlink" title="对象重命名"></a>对象重命名</h3><ul><li><p>请求地址：<code>/api/fs/rename</code></p></li><li><p>请求方式：<code>POST</code></p></li><li><p>请求头：</p><ul><li><code>Content-Type</code>: <code>application/json</code></li><li>（可空）<code>Authorization</code>：用户 token 或在 <strong>站点设置-其他</strong> 中获取到的令牌</li></ul></li><li><p>请求参数：</p><ul><li><code>path</code>：对象的相对路径</li><li><code>name</code>：新名字</li></ul></li><li><p>响应内容：无特殊响应内容.</p></li><li><p>说明：</p><ul><li>当 <code>Authorization</code> 为空时，以 <code>guest</code> 的身份上传.</li><li>请确保 token 所属用户有相应权限.</li></ul></li><li><p>Example：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Rename</span>(<span class="hljs-params">path, newName</span>):<br>    data = &#123;<br>        <span class="hljs-string">&#x27;path&#x27;</span>: path,<br>        <span class="hljs-string">&#x27;name&#x27;</span>: newName<br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> json.loads(requests.post(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;url&#125;</span>/api/fs/rename&#x27;</span>, data=json.dumps(data), headers=<span class="hljs-built_in">dict</span>(headers, **ct_json)).text)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;code&#x27;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;message&#x27;</span>: e&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
